[
  {
    "title": "Codeforces Default Template",
    "description": "",
    "code": "// Author: Matthew Li\n// It is ok to share my code anonymously for educational purposes\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (ll i = a; i < b; ++i)\n#define repr(i, a, b) for (ll i = b - 1; i >= a; --i)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define sz(x) (int)(x).size()\n\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int>> vpi;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<long long, long long> pll;\ntypedef vector<long long> vll;\ntypedef vector<pair<long long, long long>> vpll;\ntypedef long double ld;\ntypedef pair<long double, long double> pld;\ntypedef vector<long double> vld;\ntypedef vector<pair<long double, long double>> vpld;\n\nint main() {\n  // fast io\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  // iterate over tests\n  int tests;\n  cin >> tests;\n  for (int test = 0; test < tests; test++) {\n    \n  }\n}",
    "category": "Miscellaneous"
  },
  {
    "title": "Kadane's Algorithm",
    "description": "Returns the maximum nonempty subarray sum.",
    "code": "ll kadane(const vll& a) {\n  ll N = sz(a), res = LONG_LONG_MIN, sum = 0;\n  rep (i, 0, N) {\n    sum += a[i];\n    res = max(res, sum);\n    sum = max(sum, 0ll);\n  }\n  return res;\n}",
    "category": "Dynamic Programming",
    "tags": [
      "linear"
    ]
  },
  {
    "title": "Tarjan's Algorithm",
    "description": "Supply a handleScc function and make sure to call tarjans(tarjans, u) on all vertices u.",
    "code": "vll discovery(N, -1), lowlink(N, -1), ancestry;\nvector<bool> onStack(N, false);\nll tarjIdx = 0;\nauto tarjans = [&](auto tarjans, ll u) -> void {\n  discovery[u] = tarjIdx;\n  lowlink[u] = tarjIdx;\n  tarjIdx++;\n  ancestry.push_back(u);\n  onStack[u] = true;\n\n  for (const auto &v : adjList[u]) {\n    if (discovery[v] < 0) {\n      tarjans(tarjans, v);\n      lowlink[u] = min(lowlink[u], lowlink[v]);\n    } else if (onStack[v]) {\n      lowlink[u] = min(lowlink[u], lowlink[v]);\n    }\n  }\n\n  if (discovery[u] == lowlink[u]) {\n    set<ll> scc;\n    ll v = -1;\n    while (v != u) {\n      v = ancestry.back();\n      ancestry.pop_back();\n      onStack[v] = false;\n      scc.insert(v);\n    }\n    handleScc(scc);\n  }\n};",
    "category": "Graphs",
    "tags": [
      "dfs",
      "scc",
      "linear"
    ]
  },
  {
    "title": "Closest Pair of Points",
    "description": "Returns indices of two closest points in the supplied array in O(nlogn), probably.",
    "code": "pll closestPair(const vpld& a) {\n  auto dist = [&](ll i, ll j) -> ld {\n    ld dx = a[i].first - a[j].first, dy = a[i].second - a[j].second;\n    return sqrt(dx * dx + dy * dy);\n  };\n\n  assert(sz(a) > 1);\n  vll idxs(sz(a));\n  iota(all(idxs), 0);\n  sort(all(idxs), [&](ll i, ll j) -> bool {return a[i] < a[j];});\n\n  pll res = {0, 1};\n  ld mind = dist(idxs[0], idxs[1]);\n  multiset<pair<ld, ll>> leftx, lefty;\n  rep (i, 0, sz(idxs)) {\n    ll idx = idxs[i];\n    ld x = a[idx].first, y = a[idx].second;\n\n    while (!leftx.empty()) {\n      auto it = leftx.begin();\n      if (it->first < x - mind) {\n        ll jdx = it->second;\n        leftx.erase(it);\n        lefty.erase({a[jdx].second, jdx});\n      } else {\n        break;\n      }\n    }\n    auto it = lefty.lower_bound({y - mind, 0});\n    auto jt = lefty.upper_bound({y + mind, LONG_LONG_MAX});\n    while (it != jt) {\n      ll jdx = it->second;\n      if (dist(idx, jdx) < mind) {\n        res = {idx, jdx};\n        mind = dist(idx, jdx);\n      }\n      it = next(it);\n    }\n\n    leftx.insert({a[idx].first, idx});\n    lefty.insert({a[idx].second, idx});\n  }\n\n  return res;\n};",
    "category": "Geometry",
    "tags": [
      "sweepline",
      "quasilinear",
      "amortized"
    ]
  },
  {
    "title": "Sieve and Friends",
    "description": "upfs holds the unique prime factors of each number up to MAXN and divisors(x) returns all products of subsets of upfs[x] in a 2d array.",
    "code": "vll primes;\nvll upfs[MAXN + 1]; // unique prime factors\nll totient[MAXN + 1];\nvoid sieve() {\n  rep (i, 2, MAXN + 1) {\n    if (upfs[i].empty()) {\n      primes.push_back(i);\n      totient[i] = i - 1;\n\n      ll j = i;\n      while (j <= MAXN) {\n        upfs[j].push_back(i);\n        j += i;\n      }\n    }\n\n    for (const auto& p : primes) {\n      if (p * i > MAXN) break;\n      if (i % p) {\n        totient[p * i] = totient[i] * (p - 1);\n      } else {\n        totient[p * i] = totient[i] * p;\n      }\n    }\n  }\n}\n\nvector<vll> divisors(ll x) {\n  vector<vll> res;\n  auto dfs = [&](auto dfs, ll prod, ll ct, ll idx) -> void {\n    if (idx == sz(upfs[x])) {\n      if (!ct) return;\n      while (ct > sz(res)) res.push_back(vll());\n      res[ct - 1].push_back(prod);\n      return;\n    }\n    dfs(dfs, prod, ct, idx + 1);\n    dfs(dfs, prod * upfs[x][idx], ct + 1, idx + 1);\n  };\n  dfs(dfs, 1, 0, 0);\n  return res;\n}",
    "category": "Number Theory",
    "tags": [
      "primes",
      "quasilinear"
    ]
  },
  {
    "title": "Slow Totient and Friends",
    "description": "Miller-Rabin, Pollard rho, and totient function geared toward large numbers. For small ones, use sieve instead.",
    "code": "\/\/ copied from KACTL\r\nll modmul(ll a, ll b, ll M) {\r\n  __int128 res = a;\r\n  res *= b;\r\n  res %= M;\r\n  return res;\r\n}\r\nll modpow(ll b, ll e, ll mod) {\r\n  ll ans = 1;\r\n  for (; e; b = modmul(b, b, mod), e \/= 2)\r\n    if (e & 1) ans = modmul(ans, b, mod);\r\n  return ans;\r\n}\r\nbool isPrime(ll n) {\r\n  if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;\r\n  ll A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},\r\n      s = countr_zero((ull) n - 1), d = n >> s;\r\n  for (ll a : A) {\r\n    ll p = modpow(a%n, d, n), i = s;\r\n    while (p != 1 && p != n - 1 && a % n && i--)\r\n      p = modmul(p, p, n);\r\n    if (p != n - 1 && i != s) return false;\r\n  }\r\n  return true;\r\n}\r\nll pollard(ll n) {\r\n  ll x = 0, y = 0, t = 30, prd = 2, i = 1, q;\r\n  auto f = [&](ull x) { return modmul(x, x, n) + i; };\r\n  while (t++ % 40 || gcd(prd, n) == 1) {\r\n    if (x == y) x = ++i, y = f(x);\r\n    if ((q = modmul(prd, max(x,y) - min(x,y), n))) prd = q;\r\n    x = f(x), y = f(f(y));\r\n  }\r\n  return gcd(prd, n);\r\n}\r\nvll factor(ll n) {\r\n  if (n == 1) return {};\r\n  if (isPrime(n)) return {n};\r\n  ll x = pollard(n);\r\n  auto l = factor(x), r = factor(n \/ x);\r\n  l.insert(l.end(), all(r));\r\n  return l;\r\n}\r\nll totient(ll n) {\r\n  auto f = factor(n);\r\n  sort(all(f));\r\n  ll res = 1;\r\n  ll pp = 1;;\r\n  rep (i, 0, sz(f)) {\r\n    if (i + 1 == sz(f) || f[i] != f[i + 1]) {\r\n      res *= pp * f[i] - pp;\r\n      pp = 1;\r\n    } else {\r\n      pp *= f[i];\r\n    }\r\n  }\r\n  return res;\r\n}\r\n",
    "category": "Number Theory",
    "tags": [
      "primes",
      "probabilistic",
      "KACTL"
    ]
  },
  {
    "title": "Prefix Function",
    "description": "",
    "code": "// copied from cp-algo\nvll prefixFn(const string_view &s) {\n  vll res(sz(s));\n  rep(i, 1, sz(s)) {\n    ll j = res[i - 1];\n    while (j > 0 && s[i] != s[j]) {\n      j = res[j - 1];\n    }\n    if (s[i] == s[j]) {\n      j++;\n    }\n    res[i] = j;\n  }\n  return res;\n}",
    "category": "String Processing",
    "tags": [
      "linear",
      "cp-algo"
    ]
  },
  {
    "title": "Modular Integer and Rational",
    "description": "",
    "code": "\/\/ adapted from KACTL\r\nll euclid(ll a, ll b, ll &x, ll &y) {\r\n  if (!b) return x = 1, y = 0, a;\r\n  ll d = euclid(b, a % b, y, x);\r\n  return y -= a\/b * x, d;\r\n}\r\n\r\nconst ll mod = 998244353; \/\/ change to something else\r\nstruct mint {\r\n  ll x;\r\n\r\n  mint(ll xx) : x(xx) {\r\n    if (x < 0) {\r\n      x = ((-x - 1) \/ mod + 1) * mod + x;\r\n    } else {\r\n      x %= mod;\r\n    }\r\n  }\r\n\r\n  mint invert(mint a) {\r\n    ll x, y, g = euclid(a.x, mod, x, y);\r\n    assert(g == 1); return mint((x + mod) % mod);\r\n  }\r\n\r\n  void operator+=(mint b) { x += b.x; x %= mod; }\r\n  void operator-=(mint b) { x -= b.x; x += mod; x %= mod; }\r\n  void operator*=(mint b) { x *= b.x; x %= mod; }\r\n  void operator\/=(mint b) { *this *= invert(b); }\r\n  friend mint operator+(mint a, const mint& b) { a += b; return a; }\r\n  friend mint operator-(mint a, const mint& b) { a -= b; return a; }\r\n  friend mint operator*(mint a, const mint& b) { a *= b; return a; }\r\n  friend mint operator\/(mint a, const mint& b) { a \/= b; return a; }\r\n\r\n  mint operator^(ll e) {\r\n    if (!e) return 1;\r\n    mint r = *this ^ (e \/ 2); r = r * r;\r\n    return e & 1 ? *this * r : r;\r\n  }\r\n  mint operator^=(ll e) { *this = *this ^ e; }\r\n};\r\n\r\nstruct rational {\r\n  mint p, q;\r\n\r\n  rational(): p(1), q(1) {}\r\n  rational(ll x): p(x), q(1) {}\r\n  rational(ll x, ll y): p(x), q(y) {}\r\n  void operator+=(rational x) { p *= x.q; p += x.p * q; q *= x.q; }\r\n  void operator-=(rational x) { p *= x.q; p -= x.p * q; q *= x.q; }\r\n  void operator*=(rational x) { p *= x.p; q *= x.q; }\r\n  void operator\/=(rational x) { p *= x.q; q *= x.p; }\r\n  void operator^=(ll e) {\r\n    p ^= e, q ^= e;\r\n  }\r\n  friend rational operator+(rational a, const rational& b) { a += b; return a; }\r\n  friend rational operator-(rational a, const rational& b) { a -= b; return a; }\r\n  friend rational operator*(rational a, const rational& b) { a *= b; return a; }\r\n  friend rational operator\/(rational a, const rational& b) { a \/= b; return a; }\r\n  friend rational operator^(rational a, const ll& b) { a ^= b; return a; }\r\n\r\n  mint val() {\r\n    return p \/ q;\r\n  }\r\n};\r\n",
    "category": "Number Theory",
    "tags": [
      "KACTL"
    ]
  },
  {
    "title": "Polynomial String Hashing",
    "description": "Robust polynomial string hashing using two different moduli. combine_hashes finds the hash of the concatenation of two hashed substrings.",
    "code": "// mint copied from KACTL\nll euclid(ll a, ll b, ll &x, ll &y) {\n  if (!b) return x = 1, y = 0, a;\n  ll d = euclid(b, a % b, y, x);\n  return y -= a / b * x, d;\n}\n\ntemplate<ll mod> struct mint {\n  ll x;\n\n  mint(ll xx) : x(xx) {\n  }\n\n  mint operator+(mint b) { return mint((x + b.x) % mod); }\n  mint operator-(mint b) { return mint((x - b.x + mod) % mod); }\n  mint operator*(mint b) { return mint((x * b.x) % mod); }\n  mint operator/(mint b) { return *this * invert(b); }\n\n  void operator+=(mint b) { x = (x + b.x) % mod; }\n  void operator-=(mint b) { x = (x - b.x + mod) % mod; }\n  void operator*=(mint b) { x = (x * b.x) % mod; }\n  void operator/=(mint b) { x = *this * invert(b); }\n\n  bool operator==(const mint b) const { return this->x == b.x; }\n\n  mint invert(mint a) {\n    ll x, y, g = euclid(a.x, mod, x, y);\n    assert(g == 1);\n    return mint((x + mod) % mod);\n  }\n\n  mint operator^(ll e) {\n    if (!e) return mint(1);\n    mint r = *this ^ (e / 2);\n    r = r * r;\n    return e & 1 ? *this * r : r;\n  }\n};\n\nconst ll MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;\nconst mint<MOD1> POLY_HASH_COEF1 = 31;\nconst mint<MOD2> POLY_HASH_COEF2 = 37;\n\nll default_poly_hash_translate(char c) {\n  return c;\n}\n\nstruct poly_hash {\n  string str;\n  vector<mint<MOD1>> pre1;\n  vector<mint<MOD2>> pre2;\n  function<ll(char)> translate;\n\n  poly_hash(string &s, function<ll(char)> *t = NULL) {\n    str = s;\n    pre1 = vector<mint<MOD1>>(sz(str) + 1, 0);\n    pre2 = vector<mint<MOD2>>(sz(str) + 1, 0);\n    if (!t) {\n      translate = default_poly_hash_translate;\n    } else {\n      translate = *t;\n    }\n\n    rep(i, 0, sz(str)) {\n      pre1[i + 1] = pre1[i] + (mint(POLY_HASH_COEF1) ^ i) * translate(str[i]);\n      pre2[i + 1] = pre2[i] + (mint(POLY_HASH_COEF2) ^ i) * translate(str[i]);\n    }\n  }\n\n  pair<mint<MOD1>, mint<MOD2>> hash(int l, int r) {\n    return { (pre1[r + 1] - pre1[l]) / (mint(POLY_HASH_COEF1) ^ l), (pre2[r + 1] - pre2[l]) / (mint(POLY_HASH_COEF2) ^ l) };\n  }\n};\n\npair<mint<MOD1>, mint<MOD2>> combine_hashes(poly_hash &phash1, poly_hash &phash2, int l1, int r1, int l2, int r2) {\n  pair<mint<MOD1>, mint<MOD2>> hash1 = phash1.hash(l1, r1), hash2 = phash2.hash(l2, r2);\n  return { hash1.first + hash2.first * (mint(POLY_HASH_COEF1) ^ (r1 - l1 + 1)), hash1.second + hash2.second * (mint(POLY_HASH_COEF2) ^ (r1 - l1 + 1)) };\n}",
    "category": "String Processing",
    "tags": [
      "hashing",
      "probabalistic",
      "linear"
    ]
  },
  {
    "title": "Point and Line",
    "description": "TODO: add line-line intersection",
    "code": "struct point {\n  ld x, y;\n\n  point& operator+=(const point& p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n  friend point operator+(point p, const point& q) {\n    p += q;\n    return p;\n  }\n  point& operator-=(const point& p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n  friend point operator-(point p, const point& q) {\n    p -= q;\n    return p;\n  }\n\n  ld dot(const point& p) {\n    return x * p.x + y * p.y;\n  }\n  ld cross(const point& p) {\n    return x * p.y - y * p.x;\n  }\n  ld angle() {\n    if (x == 0) {\n      if (y > 0) return numbers::pi_v<ld> / 2;\n      return 3 * numbers::pi_v<ld> / 2;\n    }\n    if (x > 0) {\n      if (y >= 0) return atan(y / x);\n      return 2 * numbers::pi_v<ld> + atan(y / x);\n    }\n    return numbers::pi_v<ld> + atan(y / x);\n  }\n  ld length() {\n    return sqrt(x * x + y * y);\n  }\n};\npoint operator*(const ld& s, const point& p) {\n  return {s * p.x, s * p.y};\n}\npoint operator*(const point& p, const ld& s) {\n  return {s * p.x, s * p.y};\n}\npoint operator/(const point& p, const ld& s) {\n  return {p.x / s, p.y / s};\n}\npoint rotate(const point& p, ld theta) {\n  return {cos(theta) * p.x - sin(theta) * p.y, sin(theta) * p.x + cos(theta) * p.y};\n}\nld dist(const point& p, const point& q) {\n  return (p - q).length();\n}\n\nstruct line {\n  ld a, b, c;\n\n  line (point p, point q) {\n    a = p.y - q.y;\n    b = q.x - p.x;\n    c = -(a * p.x + b * p.y);\n  }\n};\n\nld area(const vector<point>& polygon) {\n  ld res = 0;\n  rep (i, 0, sz(polygon)) {\n    ll j = (i + 1) % sz(polygon);\n    res += polygon[i].x * polygon[j].y - polygon[i].y * polygon[j].x;\n  }\n  return res / 2;\n}",
    "category": "Geometry",
    "tags": [
      "point",
      "line"
    ]
  },
  {
    "title": "Circle and Ellipse Utilities",
    "description": "Both functions assume that the major axis is parallel to the x-axis and that the ellipse is centered at the origin, so use transformations as necessary.",
    "code": "ld segmentArea(ld r, ld t) {\n  return r * r * (t - sin(t)) / 2;\n}\n\nld ellipticSegmentArea(ld c, ld l, const point& p, const point& q) {\n  ld a = l / 2 - c, b = sqrt(a * a - c * c);\n  point pp = {p.x / a, p.y / b}, qp = {q.x / a, q.y / b};\n  if (pp.angle() > qp.angle()) swap(pp, qp);\n  return a * b * segmentArea(1, qp.angle() - pp.angle());\n}\n\npair<point, point> circleLineIntersection(ld r, const point& p, const point& q) {\n  line l(p, q);\n  ld d = sqrt(r * r - l.c * l.c / (l.a * l.a + l.b * l.b));\n  ld m = sqrt(d * d / (l.a * l.a + l.b * l.b));\n  ld x0 = -(l.a * l.c) / (l.a * l.a + l.b * l.b), y0 = -(l.b * l.c) / (l.a * l.a + l.b * l.b);\n  return {{x0 + l.b * m, y0 - l.a * m}, {x0 - l.b * m, y0 + l.a * m}};\n}\n\npair<point, point> ellipseLineIntersection(ld c, ld l, const point& p, const point& q) {\n  ld a = l / 2 - c, b = sqrt(a * a - c * c);\n  point pp = {p.x / a, p.y / b}, qp = {q.x / a, q.y / b};\n  auto [ap, bp] = circleLineIntersection(1, pp, qp);\n  return {{ap.x * a, ap.y * b}, {bp.x * a, bp.y * b}};\n}",
    "category": "Geometry",
    "tags": [
      "circle",
      "ellipse",
      "line"
    ]
  },
  {
    "title": "Unique Point and Line",
    "description": "",
    "code": "struct point {\n  ll x, y;\n\n  point& operator+=(const point& p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n  friend point operator+(point p, const point& q) {\n    p += q;\n    return p;\n  }\n  point& operator-=(const point& p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n  friend point operator-(point p, const point& q) {\n    p -= q;\n    return p;\n  }\n\n  ll dot(const point& p) {\n    return x * p.x + y * p.y;\n  }\n  ll cross(const point& p) {\n    return x * p.y - y * p.x;\n  }\n};\n\nstruct line {\n  ll a, b, c;\n\n  const bool operator< (const line& l) const {\n    if (a < l.a) return true;\n    if (a > l.a) return false;\n    if (b < l.b) return true;\n    if (b > l.b) return false;\n    if (c < l.c) return true;\n    return false;\n  }\n\n  const bool operator== (const line& l) const {\n    return a == l.a && b == l.b && c == l.c;\n  }\n\n  line (point p, point q) {\n    a = p.y - q.y;\n    b = q.x - p.x;\n    c = -(a * p.x + b * p.y);\n    fix();\n  }\n\n  void fix() {\n    if (a < 0 || (a == 0 && b < 0)) {\n      a = -a;\n      b = -b;\n      c = -c;\n    }\n\n    ll g = gcd(gcd(abs(a), abs(b)), abs(c));\n    a /= g;\n    b /= g;\n    c /= g;\n  }\n};",
    "category": "Geometry",
    "tags": [
      "point",
      "line"
    ]
  },
  {
    "title": "Order Statistic Tree",
    "description": "Gnu policy-based data structures implementation of order statistic trees. Just use set and multiset as you typically would, but you can also do stuff with order. Note that lower_bound and upper_bound swap meanings for ordered_multiset since the only change from ordered_set is switching the comparator to less_equal. By the same token, do not attempt to use find() on it.",
    "code": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
    "category": "Data Structures",
    "tags": [
      "bsearch",
      "amortized",
      "logarithmic-query",
      "logarithmic-update"
    ]
  },
  {
    "title": "Disjoint Set Union",
    "description": "DSU with path compression and union-by-size. id holds the representatives of each set. If id[x] is negative, it means that x is the representative and the set is of size -id[x]. Easily modified to support one-way unite.",
    "code": "struct disjoint_sets {\r\n  vll id;\r\n  disjoint_sets(ll N): id(vll(N, -1)) {}\r\n\r\n  ll find(ll p) {\r\n    ll idp = p;\r\n    while (id[idp] >= 0) {\r\n      idp = id[idp];\r\n    }\r\n    while (id[p] >= 0) {\r\n      ll temp = id[p];\r\n      id[p] = idp;\r\n      p = temp;\r\n    }\r\n    return idp;\r\n  }\r\n\r\n  ll size(ll p) {\r\n    ll idp = find(p);\r\n    return -id[idp];\r\n  }\r\n\r\n  void unite(ll p, ll q) {\r\n    ll idp = find(p);\r\n    ll idq = find(q);\r\n    if (idp == idq) {\r\n      return;\r\n    }\r\n    if (id[idp] < id[idq]) {\r\n      id[idq] = id[idq] + id[idp];\r\n      id[idp] = idq;\r\n      return;\r\n    }\r\n    id[idp] = id[idp] + id[idq];\r\n    id[idq] = idp;\r\n  }\r\n};\r\n",
    "category": "Data Structures",
    "tags": [
      "amortized",
      "near-constant-query",
      "near-constant-update"
    ]
  },
  {
    "title": "Sparse Table",
    "description": "Typical Sparse Table.  Ensure that the binary operation passed to the constructor is associative.  Does not support constant-time RMQ.",
    "code": "template <class T> struct sparse_table {\r\n  T (*op) (T a, T b);\r\n  unsigned int length, depth;\r\n  vector<vector<T>> table;\r\n  T zero;\r\n\r\n  sparse_table(vector<T> arr, T (*o) (T a, T b), T zero): op(o), length(arr.size()), depth(bit_width(length)), table(vector<vector<T>>(depth, vector<T>())) {\r\n    table[0] = arr;\r\n    for (unsigned int i = 1; i < depth; i++) {\r\n      for (unsigned int j = 0; j + (1 << i) <= length; j++) {\r\n        table[i].push_back(op(table[i - 1][j], table[i - 1][j + (1 << i - 1)]));\r\n      }\r\n    }\r\n  }\r\n\r\n  T query(unsigned int l, unsigned int r) {\r\n    if (l > r) return zero;\r\n    bool has_been_set = false;\r\n    T out;\r\n    for (unsigned int i = depth - 1; i >= 0; i--) {\r\n      while (l + (1 << i) - 1 <= r) {\r\n        if (!has_been_set) {\r\n          out = table[i][l];\r\n          has_been_set = true;\r\n        } else {\r\n          out = op(out, table[i][l]);\r\n        }\r\n        l += (1 << i);\r\n      }\r\n      if (!i) {\r\n        break;\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n};\r\n",
    "category": "Data Structures",
    "tags": [
      "bsearch",
      "logarithmic-query"
    ]
  },
  {
    "title": "Fenwick Tree",
    "description": "Works out-of-the box with numerical types, but supply zero to the constructor and overload operators for other types as necessary.",
    "code": "template <class info> struct fenwick_tree {\r\n  vector<info> a;\r\n  info zero;\r\n\r\n  fenwick_tree(const vector<info>& arr, info z): zero(z) {\r\n    a = vector<info>(sz(arr), zero);\r\n    rep (i, 0, sz(arr)) {\r\n      add(i, arr[i]);\r\n    }\r\n  }\r\n\r\n  info prefix(ll idx) {\r\n    if (idx < 0) {\r\n      return zero;\r\n    }\r\n    if (idx >= size()) idx = size() - 1;\r\n    info result = zero;\r\n    for (ll i = idx; i >= 0; i = (i & i + 1) - 1) {\r\n      result += a[i];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  info query(ll l, ll r) { if (l > r) return zero; return prefix(r) + -prefix(l - 1); }\r\n\r\n  void add(ll idx, info val) {\r\n    for (ll i = idx; i < a.size(); i = i | i + 1) {\r\n      a[i] += val;\r\n    }\r\n  }\r\n\r\n  void set(ll idx, info val) { add(idx, val + -query(idx, idx)); }\r\n\r\n  void push_back(info val) {\r\n    ll idx = sz(a);\r\n    ll left = idx & (idx + 1);\r\n    a.push_back(val + query(left, idx - 1));\r\n  }\r\n\r\n  unsigned int size() { return a.size(); }\r\n\r\n  \/\/ the following methods assume nonnegative elements only since they execute binary searches\r\n  \/\/ returns the lowest index where the prefix there is not less than a\r\n  ll lower_bound(info val) {\r\n    ll res = 0;\r\n    repr (i, 0, bit_width(size())) {\r\n      if (res + (1ll << i) - 1 < size() && a[res + (1ll << i) - 1] < val) {\r\n        res |= 1ll << i;\r\n        val += -a[res - 1];\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  \/\/ returns the lowest index where the prefix there is greater than a\r\n  ll upper_bound(info val) {\r\n    ll res = 0;\r\n    repr (i, 0, bit_width(size())) {\r\n      if (res + (1ll << i) - 1 < size() && a[res + (1ll << i) - 1] <= val) {\r\n        res |= 1ll << i;\r\n        val += -a[res - 1];\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  \/\/ the following methods further assume that the array elements correspond to counts\r\n  info order_of_key(ll key) { return prefix(key - 1); }\r\n  ll find_by_order(info ord) { return upper_bound(ord); }\r\n};\r\n",
    "category": "Data Structures",
    "tags": [
      "bsearch",
      "logarithmic-query",
      "logarithmic-update"
    ]
  },
  {
    "title": "Point Update Segment Tree",
    "description": "Point update segment tree.  Make sure to define the info class and overload its addition operator.",
    "code": "struct segment_tree {\n  vector<info> t;\n  int n;\n\n  segment_tree(const vector<info> &a) {\n    t = vector<info>(4 * a.size());\n    n = a.size();\n    build(1, 0, n - 1, a);\n  }\n\n  void build(int idx, int tl, int tr, const vector<info> &a) {\n    if (tl == tr) {\n      t[idx] = a[tl];\n      return;\n    }\n    int tm = tl + (tr - tl) / 2;\n    build(2 * idx, tl, tm, a);\n    build(2 * idx + 1, tm + 1, tr, a);\n    t[idx] = t[2 * idx] + t[2 * idx + 1];\n  }\n\n  inline void update(int m, const info &a) {\n    update(1, 0, n - 1, m, a);\n  }\n\n  void update(int idx, int tl, int tr, int m, const info &a) {\n    if (m < tl || m > tr) return;\n    if (tl == tr) {\n      t[idx] = a;\n      return;\n    }\n    int tm = tl + (tr - tl) / 2;\n    update(2 * idx, tl, tm, m, a);\n    update(2 * idx + 1, tm + 1, tr, m, a);\n    t[idx] = t[2 * idx] + t[2 * idx + 1];\n  }\n\n  inline info query(int l, int r) {\n    return query(1, 0, n - 1, l, r);\n  }\n\n  info query(int idx, int tl, int tr, int l, int r) {\n    if (r < l) return info();\n    if (tl == l && tr == r) return t[idx];\n    int tm = tl + (tr - tl) / 2;\n    return query(2 * idx, tl, tm, l, min(tm, r)) + query(2 * idx + 1, tm + 1, tr, max(tm + 1, l), r);\n  }\n};",
    "category": "Data Structures",
    "tags": [
      "divide-and-conquer",
      "logarithmic-query",
      "logarithmic-update"
    ]
  },
  {
    "title": "Lazy Range Update Info",
    "description": "jnfo corresponds to that information used to update the tree and info are the actual tree members. Overload their operators as necessary and the tree logic should not need to be touched.",
    "code": "struct jnfo {\r\n  ll a;\r\n  jnfo(): a(0) {}\r\n  jnfo(ll b): a(b) {}\r\n  jnfo& operator+=(const jnfo& x) {\r\n    a += x.a;\r\n    return *this;\r\n  }\r\n};\r\n\r\nstruct info {\r\n  ll val;\r\n  \/\/ info() should be the merge identity\r\n  info(): val(LONG_LONG_MIN) {}\r\n  \/\/ implicitly, it is expected that jnfo() is an additive identity\r\n  info(ll v): val(v) {}\r\n  \/\/ updating operation\r\n  info& operator+=(const jnfo& x) {\r\n    val += x.a;\r\n    return *this;\r\n  }\r\n  friend info operator+(info x, const jnfo& y) {\r\n    x += y;\r\n    return x;\r\n  }\r\n  \/\/ merging operation\r\n  info& operator*=(const info& x) {\r\n    val = max(val, x.val);\r\n    return *this;\r\n  }\r\n  friend info operator*(info x, const info& y) {\r\n    x *= y;\r\n    return x;\r\n  }\r\n};\r\n",
    "category": "Data Structures",
    "tags": [
      "divide-and-conquer"
    ]
  },
  {
    "title": "Lazy Range Update Segment Tree",
    "description": "Generalist lazy prop segment tree. Use with Lazy Range Update Info. jnfo corresponds to that information used to update the tree and info are the actual tree members. Overload their operators as necessary and the tree logic should not need to be touched. Tested on Range Affine Range Sum.",
    "code": "template <class info, class jnfo> struct lazy_segtree {\r\n  vector<info> a;\r\n  vector<jnfo> lazy;\r\n  ll N;\r\n\r\n  lazy_segtree(const vll& arr) {\r\n    N = arr.size();\r\n    a = vector<info>(4 * N);\r\n    lazy = vector<jnfo>(4 * N);\r\n    build(1, 0, N - 1, arr);\r\n  }\r\n\r\n  void build(ll idx, ll tl, ll tr, const vll& arr) {\r\n    if (tl == tr) {\r\n      a[idx] = info(arr[tl]);\r\n      return;\r\n    }\r\n    ll tm = tl + (tr - tl) \/ 2;\r\n    build(2 * idx, tl, tm, arr);\r\n    build(2 * idx + 1, tm + 1, tr, arr);\r\n    a[idx] = a[2 * idx] * a[2 * idx + 1];\r\n  }\r\n\r\n  void push(ll idx) {\r\n    a[idx * 2] += lazy[idx];\r\n    a[idx * 2 + 1] += lazy[idx];\r\n    lazy[idx * 2] += lazy[idx];\r\n    lazy[idx * 2 + 1] += lazy[idx];\r\n    lazy[idx] = jnfo();\r\n  }\r\n\r\n  void update(ll l, ll r, jnfo x) {\r\n    update(1, 0, N - 1, l, r, x);\r\n  }\r\n\r\n  void update(ll idx, ll tl, ll tr, ll l, ll r, jnfo x) {\r\n    if (l > r) return;\r\n    if (l == tl && r == tr) {\r\n      a[idx] += x;\r\n      lazy[idx] += x;\r\n    } else {\r\n      push(idx);\r\n      ll tm = tl + (tr - tl) \/ 2;\r\n      update(idx * 2, tl, tm, l, min(r, tm), x);\r\n      update(idx * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);\r\n      a[idx] = a[idx * 2] * a[idx * 2 + 1];\r\n    }\r\n  }\r\n\r\n  info query(ll l, ll r) {\r\n    return query(1, 0, N - 1, l, r);\r\n  }\r\n\r\n  info query(ll idx, ll tl, ll tr, ll l, ll r) {\r\n    if (l > r) return info();\r\n    if (tl == l && tr == r) return a[idx];\r\n    push(idx);\r\n    ll tm = tl + (tr - tl) \/ 2;\r\n    return query(2 * idx, tl, tm, l, min(tm, r)) * query(2 * idx + 1, tm + 1, tr, max(tm + 1, l), r);\r\n  }\r\n};\r\n",
    "category": "Data Structures",
    "tags": [
      "divide-and-conquer",
      "logarithmic-query",
      "logarithmic-update"
    ]
  },
  {
    "title": "Li Chao Tree",
    "description": "Li Chao Tree implemented as a dynamic segment tree on lines. Tested on Segment Add Get Min.",
    "code": "struct line {\n  ll a, b;\n\n  ll val(ll x) {\n    return a * x + b;\n  }\n};\n\nstruct node {\n  node * left = NULL, * right = NULL;\n  line v;\n  bool has_line = false;\n  ll l, r;\n\n  node(ll l, ll r) {\n    this->l = l;\n    this->r = r;\n  }\n\n  void ensure_left() {\n    if (!left && l < r) {\n      ll m = l + (r - l) / 2;\n      left = new node(l, m);\n      if (has_line) {\n        left->v = v;\n      }\n    }\n  }\n\n  void ensure_right() {\n    if (!right && l < r) {\n      ll m = l + (r - l) / 2;\n      right = new node(m + 1, r);\n      if (has_line) {\n        right->has_line = true;\n        right->v = v;\n      }\n    }\n  }\n};\n\nstruct li_chao_tree {\n  ll ml, mr;\n  node * root = NULL;\n\n  li_chao_tree(ll l, ll r) {\n    ml = l;\n    mr = r;\n    root = new node(l, r);\n  };\n\n  inline void update(line v, ll l, ll r) {\n    update(root, v, ml, mr, l, r);\n  }\n\n  void update(node * cur, line v, ll tl, ll tr, ll l, ll r) {\n    if (l > r) return;\n    if (tl == l && tr == r) {\n      update_node(cur, v);\n    } else if (tl < tr) {\n      ll tm = tl + (tr - tl) / 2;\n      if (l <= tm) {\n        cur->ensure_left();\n        update(cur->left, v, tl, tm, l, min(tm, r));\n      }\n      if (r > tm) {\n        cur->ensure_right();\n        update(cur->right, v, tm + 1, tr, max(tm + 1, l), r);\n      }\n    }\n  }\n\n  void update_node(node * cur, line v) {\n    ll tl = cur->l, tr = cur->r;\n    ll tm = tl + (tr - tl) / 2;\n\n    if (!cur->has_line) {\n      // currently no line, replace\n      cur->has_line = true;\n      cur->v = v;\n      return;\n    }\n\n    // there is already a line\n    bool gl = v.val(tl) > cur->v.val(tl), gm = v.val(tm) > cur->v.val(tm), gr = v.val(tr) > cur->v.val(tr);\n    if (gl && gr) {\n      cur->has_line = true;\n      cur->v = v;\n      return;\n    }\n    if (!gl && !gr) return;\n\n    if (gm) swap(cur->v, v);\n    if (gl != gm) {\n      cur->ensure_left();\n      update_node(cur->left, v);\n    } else if (gr != gm) {\n      cur->ensure_right();\n      update_node(cur->right, v);\n    }\n  }\n\n  inline ll query(ll x) {\n    return query(root, x);\n  }\n\n  ll query(node * cur, ll x) {\n    ll tl = cur->l, tr = cur->r;\n    ll tm = tl + (tr - tl) / 2;\n    ll ans = LONG_LONG_MIN;\n    if (cur->has_line) {\n      ans = cur->v.val(x);\n    }\n    if (x <= tm && cur->left) {\n      ans = max(ans, query(cur->left, x));\n    } else if (x > tm && cur->right) {\n      ans = max(ans, query(cur->right, x));\n    }\n    return ans;\n  }\n};",
    "category": "Data Structures",
    "tags": [
      "convex-hull",
      "bsearch",
      "divide-and-conquer",
      "logarithmic-query",
      "logarithmic-update"
    ]
  },
  {
    "title": "Heavy-Light Decomposition",
    "description": "Decomposes a tree to support lazy segment tree path queries and updates. Typically should be used with Lazy Range Update Segment Tree.",
    "code": "\/\/ adapted from KACTL\r\ntemplate <bool edgeVals> struct heavy_light {\r\n  \/\/ to be brave is to risk MLE for no good reason\r\n  ll N, time = 0;\r\n  vector<vll> cld;\r\n  vll par, weight, light, tin;\r\n  lazy_segtree sgtr;\r\n  heavy_light(const vector<vll>& adjList, ll root = 0):\r\n  N(sz(adjList)),\r\n  cld(N),\r\n  par(N, -1),\r\n  weight(N, 0),\r\n  light(N, 0),\r\n  tin(N),\r\n  sgtr(vll(N, 0)) {\r\n    dfsWeight(root, -1, adjList);\r\n    dfsLight(root);\r\n  }\r\n\r\n  void dfsWeight(ll u, ll w, const vector<vll>& adjList) {\r\n    for (const auto& v : adjList[u]) {\r\n      if (v != w) {\r\n        cld[u].push_back(v);\r\n        par[v] = u;\r\n        dfsWeight(v, u, adjList);\r\n        weight[u] += weight[v];\r\n        if (weight[v] > weight[cld[u][0]]) {\r\n          swap(cld.back(), cld[0]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  void dfsLight(ll u) {\r\n    tin[u] = time++;\r\n    for (const auto& v : cld[u]) {\r\n      if (v == cld[u][0]) {\r\n        light[v] = light[u];\r\n      } else {\r\n        light[v] = v;\r\n      }\r\n      dfsLight(v);\r\n    }\r\n  }\r\n\r\n  info queryPath(ll u, ll v) {\r\n    info res;\r\n    for (;; v = par[light[v]]) {\r\n      if (tin[u] > tin[v]) swap(u, v);\r\n      if (light[u] == light[v]) break;\r\n      res = res * sgtr.query(tin[light[v]], tin[v]);\r\n    }\r\n    return res * sgtr.query(tin[u] + edgeVals, tin[v]);\r\n  }\r\n\r\n  void updatePath(ll u, ll v, ll val) {\r\n    for (;; v = par[light[v]]) {\r\n      if (tin[u] > tin[v]) swap(u, v);\r\n      if (light[u] == light[v]) break;\r\n      sgtr.update(tin[light[v]], tin[v], val);\r\n    }\r\n    if (tin[u] > tin[v]) swap(u, v);\r\n    sgtr.update(tin[u] + edgeVals, tin[v], val);\r\n  }\r\n\r\n  \/\/ behavior depends on root passed to constructor\r\n  \/\/ NOTE: this has not been tested, just seems like it should work LOL\r\n  info querySubtree(ll u) {\r\n    return sgtr.query(tin[u] + edgeVals, tin[u] + weight[u] - 1);\r\n  }\r\n\r\n  void updateSubtree(ll u, ll v, ll val) {\r\n    return sgtr.update(tin[u] + edgeVals, tin[u] + weight[u] - 1, val);\r\n  }\r\n};\r\n",
    "category": "Graphs",
    "tags": [
      "tree",
      "dfs",
      "divide-and-conquer",
      "logarithmic-squared-query",
      "logarithmic-squared-update",
      "KACTL"
    ]
  },
  {
    "title": "Segment Tree Beats!",
    "description": "Tested on Range Chmin Chmax Add Range Sum. If implementing this was bad, then I don't want to imagine what the Charlotte Segment Tree is like.",
    "code": "struct jnfo {\r\n  ll a;\r\n  jnfo(): a(0) {}\r\n  jnfo(ll b): a(b) {}\r\n  jnfo& operator+=(const jnfo& x) {\r\n    a += x.a;\r\n    return *this;\r\n  }\r\n};\r\n\r\nconst ll infty = 1e18;\r\nstruct info {\r\n  ll sum, width, min1, min2, minc, max1, max2, maxc;\r\n  \/\/ info() should be the merge identity\r\n  info(): sum(0), width(1), min1(infty), min2(infty), minc(1), max1(-infty), max2(-infty), maxc(1) {}\r\n  \/\/ implicitly, it is expected that jnfo() is an additive identity\r\n  info(ll x): sum(x), width(1), min1(x), min2(infty), minc(1), max1(x), max2(-infty), maxc(1) {}\r\n  \/\/ updating operation\r\n  info& operator+=(const jnfo& x) {\r\n    sum += x.a * width;\r\n    min1 += x.a;\r\n    min2 += x.a;\r\n    max1 += x.a;\r\n    max2 += x.a;\r\n    return *this;\r\n  }\r\n  friend info operator+(info x, const jnfo& y) {\r\n    x += y;\r\n    return x;\r\n  }\r\n  \/\/ merging operation\r\n  info& operator*=(const info& x) {\r\n    sum += x.sum;\r\n    width += x.width;\r\n    if (min1 > x.min1) {\r\n      min2 = min(min1, x.min2);\r\n      min1 = x.min1;\r\n      minc = x.minc;\r\n    } else if (min1 == x.min1) {\r\n      min2 = min(min2, x.min2);\r\n      minc += x.minc;\r\n    } else {\r\n      min2 = min(min2, x.min1);\r\n    }\r\n    if (max1 < x.max1) {\r\n      max2 = max(max1, x.max2);\r\n      max1 = x.max1;\r\n      maxc = x.maxc;\r\n    } else if (max1 == x.max1) {\r\n      max2 = max(max2, x.max2);\r\n      maxc += x.maxc;\r\n    } else {\r\n      max2 = max(max2, x.max1);\r\n    }\r\n    return *this;\r\n  }\r\n  friend info operator*(info x, const info& y) {\r\n    x *= y;\r\n    return x;\r\n  }\r\n};\r\n\r\nstruct lazy_segtree {\r\n  vector<info> a;\r\n  vector<jnfo> lazy;\r\n  ll N;\r\n\r\n  lazy_segtree(const vll& arr) {\r\n    N = arr.size();\r\n    a = vector<info>(4 * N);\r\n    lazy = vector<jnfo>(4 * N);\r\n    build(1, 0, N - 1, arr);\r\n  }\r\n\r\n  void build(ll idx, ll tl, ll tr, const vll& arr) {\r\n    if (tl == tr) {\r\n      a[idx] = info(arr[tl]);\r\n      return;\r\n    }\r\n    ll tm = tl + (tr - tl) \/ 2;\r\n    build(2 * idx, tl, tm, arr);\r\n    build(2 * idx + 1, tm + 1, tr, arr);\r\n    a[idx] = a[2 * idx] * a[2 * idx + 1];\r\n  }\r\n\r\n  void pushAdd(ll idx) {\r\n    a[idx * 2] += lazy[idx];\r\n    a[idx * 2 + 1] += lazy[idx];\r\n\r\n    lazy[idx * 2] += lazy[idx];\r\n    lazy[idx * 2 + 1] += lazy[idx];\r\n    lazy[idx] = jnfo();\r\n  }\r\n\r\n  void pushMin(ll idx) {\r\n    auto p = [&](ll idx, ll jdx) -> void {\r\n      if (a[idx].min1 >= a[jdx].max1) {\r\n        a[jdx].max1 = a[idx].min1;\r\n        a[jdx].max2 = -infty;\r\n        a[jdx].min2 = infty;\r\n      } else if (a[idx].min1 > a[jdx].max2 && a[jdx].min1 <= a[jdx].max2) {\r\n        a[jdx].max2 = a[idx].min1;\r\n      }\r\n      a[jdx].sum -= a[jdx].min1 * a[jdx].minc;\r\n      a[jdx].min1 = max(a[jdx].min1, a[idx].min1);\r\n      a[jdx].sum += a[jdx].min1 * a[jdx].minc;\r\n    };\r\n\r\n    p(idx, 2 * idx);\r\n    p(idx, 2 * idx + 1);\r\n  }\r\n\r\n  void pushMax(ll idx) {\r\n    auto p = [&](ll idx, ll jdx) -> void {\r\n      if (a[idx].max1 <= a[jdx].min1) {\r\n        a[jdx].min1 = a[idx].max1;\r\n        a[jdx].min2 = infty;\r\n        a[jdx].max2 = -infty;\r\n      } else if (a[idx].max1 < a[jdx].min2 && a[jdx].min1 <= a[jdx].max2) {\r\n        a[jdx].min2 = a[idx].max1;\r\n      }\r\n      a[jdx].sum -= a[jdx].max1 * a[jdx].maxc;\r\n      a[jdx].max1 = min(a[jdx].max1, a[idx].max1);\r\n      a[jdx].sum += a[jdx].max1 * a[jdx].maxc;\r\n    };\r\n\r\n    p(idx, 2 * idx);\r\n    p(idx, 2 * idx + 1);\r\n  }\r\n\r\n  void push(ll idx) {\r\n    pushAdd(idx);\r\n    pushMin(idx);\r\n    pushMax(idx);\r\n  }\r\n\r\n  void add(ll l, ll r, jnfo x) {\r\n    add(1, 0, N - 1, l, r, x);\r\n  }\r\n\r\n  void add(ll idx, ll tl, ll tr, ll l, ll r, jnfo x) {\r\n    if (l > r) return;\r\n    if (l == tl && r == tr) {\r\n      a[idx] += x;\r\n      lazy[idx] += x;\r\n    } else {\r\n      push(idx);\r\n      ll tm = tl + (tr - tl) \/ 2;\r\n      add(idx * 2, tl, tm, l, min(r, tm), x);\r\n      add(idx * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);\r\n      a[idx] = a[idx * 2] * a[idx * 2 + 1];\r\n    }\r\n  }\r\n\r\n  void chmin(ll l, ll r, ll x) {\r\n    chmin(1, 0, N - 1, l, r, x);\r\n  }\r\n\r\n  void chmin(ll idx, ll tl, ll tr, ll l, ll r, ll x) {\r\n    if (l > r) return;\r\n    if (x >= a[idx].max1) return;\r\n    if (l == tl && r == tr) {\r\n      if (x > a[idx].max2) {\r\n        if (a[idx].max1 == a[idx].min2) {\r\n          a[idx].min2 = x;\r\n        } else if (a[idx].max2 < a[idx].min1) {\r\n          a[idx].min1 = x;\r\n        }\r\n        a[idx].sum -= a[idx].max1 * a[idx].maxc;\r\n        a[idx].max1 = x;\r\n        a[idx].sum += a[idx].max1 * a[idx].maxc;\r\n        return;\r\n      }\r\n    }\r\n    push(idx);\r\n    ll tm = tl + (tr - tl) \/ 2;\r\n    chmin(idx * 2, tl, tm, l, min(r, tm), x);\r\n    chmin(idx * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);\r\n    a[idx] = a[idx * 2] * a[idx * 2 + 1];\r\n  }\r\n\r\n  void chmax(ll l, ll r, ll x) {\r\n    chmax(1, 0, N - 1, l, r, x);\r\n  }\r\n\r\n  void chmax(ll idx, ll tl, ll tr, ll l, ll r, ll x) {\r\n    if (l > r) return;\r\n    if (x <= a[idx].min1) return;\r\n    if (l == tl && r == tr) {\r\n      if (x < a[idx].min2) {\r\n        if (a[idx].min1 == a[idx].max2) {\r\n          a[idx].max2 = x;\r\n        } else if (a[idx].max2 < a[idx].min1) {\r\n          a[idx].max1 = x;\r\n        }\r\n        a[idx].sum -= a[idx].min1 * a[idx].minc;\r\n        a[idx].min1 = x;\r\n        a[idx].sum += a[idx].min1 * a[idx].minc;\r\n        return;\r\n      }\r\n    }\r\n    push(idx);\r\n    ll tm = tl + (tr - tl) \/ 2;\r\n    chmax(idx * 2, tl, tm, l, min(r, tm), x);\r\n    chmax(idx * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);\r\n    a[idx] = a[idx * 2] * a[idx * 2 + 1];\r\n  }\r\n\r\n  info query(ll l, ll r) {\r\n    return query(1, 0, N - 1, l, r);\r\n  }\r\n\r\n  info query(ll idx, ll tl, ll tr, ll l, ll r) {\r\n    if (l > r) return info();\r\n    if (tl == l && tr == r) return a[idx];\r\n    push(idx);\r\n    ll tm = tl + (tr - tl) \/ 2;\r\n    return query(2 * idx, tl, tm, l, min(tm, r)) * query(2 * idx + 1, tm + 1, tr, max(tm + 1, l), r);\r\n  }\r\n};\r\n",
    "category": "Data Structures",
    "tags": [
      "divide-and-conquer",
      "amortized",
      "logarithmic-query",
      "logarithmic-update"
    ]
  },
  {
    "title": "Stress Testing Script",
    "description": "Python script allowing automated stress testing. Expects main.cpp and slow.cpp.",
    "code": "import difflib\r\nimport os\r\nimport random\r\nimport subprocess\r\n\r\nTEST_LIMIT = 1000\r\n\r\ndef gen():\r\n    # should return a string that represents the input for the test cases\r\n    pass\r\n\r\ndef main():\r\n    try:\r\n        subprocess.run(\"g++ main.cpp -o main\")\r\n        subprocess.run(\"g++ slow.cpp -o slow\")\r\n\r\n        def test(input_str, i):\r\n            main_res = subprocess.run(\r\n                os.path.join(\".\", \"main\"),\r\n                input=input_str,\r\n                capture_output=True,\r\n                text=True\r\n            )\r\n            main_out = main_res.stdout\r\n            main_ret = main_res.returncode\r\n\r\n            slow_res = subprocess.run(\r\n                os.path.join(\".\", \"slow\"),\r\n                input=input_str,\r\n                capture_output=True,\r\n                text=True\r\n            )\r\n            slow_out = slow_res.stdout\r\n            slow_ret = slow_res.returncode\r\n\r\n            if (main_ret != 0 or slow_ret != 0):\r\n                print(\"\\033[31mError in execution:\") # Red\r\n                if main_ret != 0:\r\n                    print(f\"main returned {main_ret}\\n\")\r\n                if slow_ret != 0:\r\n                    print(f\"slow returned {slow_ret}\\n\")\r\n                print(f\"Test {i} input:\\n{input_str}\")\r\n                print(\"\\033[0m\", end=\"\") # Reset\r\n                return None\r\n\r\n            main_lines = main_out.splitlines(keepends=True)\r\n            slow_lines = slow_out.splitlines(keepends=True)\r\n\r\n            return list(difflib.unified_diff(main_lines, slow_lines, fromfile='main', tofile='slow'))\r\n        \r\n        for i in range(1, TEST_LIMIT + 1):\r\n            input_str = gen()\r\n            diff = test(input_str, i)\r\n            if diff:\r\n                print(\"\\033[31m\" + f\"Test {i} outputs differ:\") # Red\r\n                for line in diff:\r\n                    if line.startswith('+'):\r\n                        print(\"\\033[32m\" + line, end='') # Green\r\n                    elif line.startswith('-'):\r\n                        print(\"\\033[31m\" + line, end='') # Red\r\n                    else:\r\n                        print(\"\\033[0m\" + line, end='') # Reset\r\n                print(\"\\033[0m\", end=\"\") # Reset\r\n                print(f\"Test {i} input:\\n{input_str}\")\r\n                break\r\n            else:\r\n                print(\"\\033[32m\" + f\"Test {i} outputs match!\" + \"\\033[0m\") # Green\r\n\r\n    except subprocess.CalledProcessError as e:\r\n        print(f\"Error executing command: {e}\")\r\n        print(f\"Command: {e.cmd}\")\r\n        print(f\"Return Code: {e.returncode}\")\r\n        print(f\"Output: {e.stdout}\")\r\n        print(f\"Error Output: {e.stderr}\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
    "category": "Miscellaneous",
    "tags": [
      "python"
    ]
  },
  {
    "title": "Longest Increasing Subsequence",
    "description": "Returns indices. Tested on Longest Increasing Subsequence on Kattis.",
    "code": "\/\/ returns indices\r\nvll longestIncrSubseq(const vll& a) {\r\n  ll N = sz(a);\r\n  vll end(N + 1, LONG_LONG_MAX), idx(N + 1, -1), par(N, -1);\r\n  end[0] = LONG_LONG_MIN;\r\n\r\n  ll len = 0;\r\n  rep (i, 0, N) {\r\n    ll lo = 0, hi = N;\r\n    while (lo < hi) {\r\n      ll mid = lo + (hi - lo) \/ 2;\r\n\r\n      if (end[mid] >= a[i]) {\r\n        hi = mid;\r\n      } else {\r\n        lo = mid + 1;\r\n      }\r\n    }\r\n\r\n    end[lo] = a[i];\r\n    idx[lo] = i;\r\n    if (lo) par[i] = idx[lo - 1];\r\n    len = max(len, lo);\r\n  }\r\n\r\n  vll seq;\r\n  ll pos = idx[len];\r\n  while (pos >= 0) {\r\n    seq.push_back(pos);\r\n    pos = par[pos];\r\n  }\r\n  reverse(all(seq));\r\n\r\n  return seq;\r\n}\r\n",
    "category": "Dynamic Programming",
    "tags": [
      "bsearch",
      "linearithmic"
    ]
  },
  {
    "title": "Centroid Decomposition",
    "description": "finds the centroid tree, of a tree specified by adjList.",
    "code": "struct centroid_decomp {\r\n  ll N;\r\n  vector<vll> cld;\r\n  vll par;\r\n  ll root;\r\n  vll tin, tout;\r\n\r\n  centroid_decomp(const vector<vll>& adjList): N(sz(adjList)), cld(vector<vll>(N)), par(vll(N, -1)), tin(vll(N)), tout(vll(N)) {\r\n    vector<bool> deleted(N, false);\r\n    vll weight(N, 0);\r\n    \/\/ finds centroid in cur_root's subtree\r\n    auto centroid = [&](ll cur_root) -> ll {\r\n      auto dfsWeight = [&](auto dfsWeight, ll u, ll w) -> void {\r\n        weight[u] = 1;\r\n        for (const auto& v : adjList[u]) {\r\n          if (!deleted[v] && v != w) {\r\n            dfsWeight(dfsWeight, v, u);\r\n            weight[u] += weight[v];\r\n          }\r\n        }\r\n      };\r\n      dfsWeight(dfsWeight, cur_root, -1);\r\n\r\n      auto dfsCentroid = [&](auto dfsCentroid, ll u, ll w) -> ll {\r\n        bool failed = false;\r\n        for (const auto& v : adjList[u]) {\r\n          if (!deleted[v]) {\r\n            ll subWeight;\r\n            if (v == w) {\r\n              subWeight = weight[cur_root] - weight[u];\r\n            } else {\r\n              subWeight = weight[v];\r\n            }\r\n            if (subWeight > weight[cur_root] \/ 2) {\r\n              failed = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (!failed) return u;\r\n        for (const auto& v : adjList[u]) {\r\n          if (!deleted[v] && v != w) {\r\n            ll found = dfsCentroid(dfsCentroid, v, u);\r\n            if (found >= 0) return found;\r\n          }\r\n        }\r\n        return -1;\r\n      };\r\n      return dfsCentroid(dfsCentroid, cur_root, -1);\r\n    };\r\n\r\n    \/\/ u is the root of the tree to search in, w is the last centroid\r\n    ll time = 0;\r\n    auto dfs = [&](auto dfs, ll u, ll w) -> void {\r\n      ll v = centroid(u);\r\n      tin[v] = time++;\r\n      if (w >= 0) {\r\n        cld[w].push_back(v);\r\n        par[v] = w;\r\n      } else {\r\n        root = v;\r\n      }\r\n      deleted[v] = true;\r\n      for (const auto& x : adjList[v]) {\r\n        if (!deleted[x]) {\r\n          dfs(dfs, x, v);\r\n        }\r\n      }\r\n      tout[v] = time++;\r\n    };\r\n    dfs(dfs, 0, -1);\r\n  }\r\n\r\n  bool anc(ll u, ll v) {\r\n    return tin[u] <= tin[v] && tout[u] >= tout[v];\r\n  }\r\n};\r\n",
    "category": "Graphs",
    "tags": [
      "tree",
      "dfs",
      "divide-and-conquer",
      "linearithmic"
    ]
  },
  {
    "title": "Binary Lifting",
    "description": "",
    "code": "\/\/ adapted from cp-algo\r\nstruct binary_lifting {\r\n  ll N, levels;\r\n  vector<vll> cld, par;\r\n  vll tin, tout, depth;\r\n\r\n  binary_lifting(const vector<vll>& adjList): N(sz(adjList)), levels(bit_width((unsigned) N - 1)), cld(vector<vll>(N)), par(vector<vll>(N, vll(levels))), tin(vll(N)), tout(vll(N)), depth(vll(N)) {\r\n    ll time = 0;\r\n    ll dep = 0;\r\n    auto dfs = [&](auto dfs, ll u, ll w) -> void {\r\n      tin[u] = time++;\r\n      depth[u] = dep;\r\n      par[u][0] = w;\r\n      rep (i, 1, levels) {\r\n        par[u][i] = par[par[u][i - 1]][i - 1];\r\n      }\r\n      for (const auto& v : adjList[u]) {\r\n        if (v != w) {\r\n          cld[u].push_back(v);\r\n          dep++;\r\n          dfs(dfs, v, u);\r\n          dep--;\r\n        }\r\n      }\r\n      tout[u] = time++;\r\n    };\r\n    dfs(dfs, 0, 0);\r\n  }\r\n\r\n  bool anc(ll u, ll v) {\r\n    return tin[u] <= tin[v] && tout[u] >= tout[v];\r\n  }\r\n\r\n  ll lca(ll u, ll v) {\r\n    if (anc(u, v)) return u;\r\n    if (anc(v, u)) return v;\r\n    repr (i, 0, levels) {\r\n      if (!anc(par[u][i], v)) {\r\n        u = par[u][i];\r\n      }\r\n    }\r\n    return par[u][0];\r\n  }\r\n\r\n  ll dist(ll u, ll v) {\r\n    ll w = lca(u, v);\r\n    return depth[u] + depth[v] - 2 * depth[w];\r\n  }\r\n};\r\n",
    "category": "Graphs",
    "tags": [
      "tree",
      "dfs",
      "bsearch",
      "linearithmic",
      "cp-algo"
    ]
  },
  {
    "title": "Lazy Range Update Splay Tree",
    "description": "Same idea as the lazy range update segment tree, but now with way way more operations. Tested on Dynamic Sequence Range Affine Range Sum.",
    "code": "\/\/ adapted from zhtluo\r\ntemplate <class info, class jnfo> struct splay_tree {\r\n  struct node {\r\n    node *p, *c[2];\r\n    ll w;\r\n    bool rev;\r\n    info val, pro;\r\n    jnfo lazy;\r\n\r\n    node(): val(info()), pro(info()), w(1), rev(false) {\r\n      p = c[0] = c[1] = nullptr;\r\n    }\r\n    node(info v): val(v), pro(v), w(1), rev(false) {\r\n      p = c[0] = c[1] = nullptr;\r\n    }\r\n    ~node() {\r\n      rep (i, 0, 2) {\r\n        if (c[i]) {\r\n          delete c[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    void update() {\r\n      w = 1; pro = val;\r\n      rep (i, 0, 2) {\r\n        if (c[i]) {\r\n          w += c[i]->w;\r\n          pro *= c[i]->pro;\r\n        }\r\n      }\r\n    }\r\n\r\n    void push() {\r\n      rep (i, 0, 2) {\r\n        if (c[i]) {\r\n          c[i]->val += lazy;\r\n          c[i]->pro += lazy;\r\n          c[i]->lazy += lazy;\r\n          if (rev) {\r\n            c[i]->rev ^= rev;\r\n          }\r\n        }\r\n      }\r\n      lazy = jnfo();\r\n      if (rev) {\r\n        swap(c[0], c[1]);\r\n      }\r\n      rev = false;\r\n    }\r\n  };\r\n\r\n  node* root;\r\n\r\n  splay_tree() {\r\n    root = new node;\r\n    root->c[1] = new node;\r\n    root->c[1]->p = root;\r\n    root->c[1]->update();\r\n    root->update();\r\n  }\r\n\r\n  ll walk(node *x, ll &dir, ll &pos) {\r\n    x->push();\r\n    ll s = x->c[0] ? x->c[0]->w : 0;\r\n    dir = s < pos;\r\n    if (dir) pos -= s + 1;\r\n    return s;\r\n  }\r\n\r\n  node *find(ll pos, bool sp = true) {\r\n    pos++;\r\n    node *cur = root;\r\n    ll dir;\r\n    while (true) {\r\n      ll s = walk(cur, dir, pos);\r\n      if (!dir && pos == s) {\r\n        break;\r\n      }\r\n      cur = cur->c[dir];\r\n    }\r\n    if (sp) splay(cur);\r\n    return cur;\r\n  }\r\n\r\n  void insert(ll pos, info val) {\r\n    node *x = new node(val);\r\n    pos++;\r\n    node *cur = root;\r\n    ll dir;\r\n    while (true) {\r\n      walk(cur, dir, pos);\r\n      if (cur->c[dir]) cur = cur->c[dir];\r\n      else break;\r\n    }\r\n    cur->c[dir] = x;\r\n    x->p = cur;\r\n    splay(x);\r\n  }\r\n\r\n  void rotate(node *x) {\r\n    \/\/ x->p->c[0] == x is an idiom for the direction which x is not in\r\n    \/\/ similarly, x->p->c[1] == x is an idiom for the direction which x is in\r\n    ll dir = x->p->c[0] == x;\r\n    node *y = x->p, *z = y->p, *b = x->c[dir];\r\n    if (z) {\r\n      z->c[z->c[1] == y] = x;\r\n    }\r\n    x->p = z;\r\n    x->c[dir] = y;\r\n    y->p = x;\r\n    y->c[!dir] = b;\r\n    if (b) {\r\n      b->p = y;\r\n    }\r\n    y->update();\r\n    x->update();\r\n  }\r\n\r\n  void splay(node *x, node *r = nullptr) {\r\n    while (x->p != r) {\r\n      node *y = x->p, *z = y->p;\r\n      if (z == r) {\r\n        rotate(x);\r\n      } else if ((y->c[0] == x) == (z->c[0] == y)) {\r\n        rotate(y);\r\n        rotate(x);\r\n      } else {\r\n        rotate(x);\r\n        rotate(x);\r\n      }\r\n    }\r\n    if (!r) {\r\n      root = x;\r\n    }\r\n  }\r\n\r\n  info query(ll l, ll r) {\r\n    if (l > r) return info();\r\n    find(r + 1);\r\n    splay(find(l - 1, false), root);\r\n    return root->c[0]->c[1]->pro;\r\n  }\r\n\r\n  void update(ll l, ll r, jnfo x) {\r\n    if (l > r) return;\r\n    find(r + 1);\r\n    splay(find(l - 1, false), root);\r\n    root->c[0]->c[1]->val += x;\r\n    root->c[0]->c[1]->pro += x;\r\n    root->c[0]->c[1]->lazy += x;\r\n    root->c[0]->update();\r\n    root->update();\r\n  }\r\n\r\n  void erase(ll l, ll r) {\r\n    if (l > r) return;\r\n    find(r + 1);\r\n    splay(find(l - 1, false), root);\r\n    node *cut = root->c[0]->c[1];\r\n    root->c[0]->c[1] = nullptr;\r\n    delete cut;\r\n    root->c[0]->update();\r\n    root->update();\r\n  }\r\n\r\n  void reverse(ll l, ll r) {\r\n    if (l > r) return;\r\n    find(r + 1);\r\n    splay(find(l - 1, false), root);\r\n    root->c[0]->c[1]->rev ^= true;\r\n  }\r\n\r\n  ll size() {\r\n    return root->w - 2;\r\n  }\r\n};\r\n",
    "category": "Data Structures",
    "tags": [
      "bsearch",
      "amortized",
      "logarithmic-query",
      "logarithmic-update",
      "zhtluo"
    ]
  }
]